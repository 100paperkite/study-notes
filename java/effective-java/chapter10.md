# 10장 - 예외

## [69] 예외는 진짜 예외 상황에서만 사용하라

1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다(최적화에 별로 신경쓰지 않았을 가능성이 크다)
2. `try-catch` 블록 안에서는 JVM이 적용할 수 있는 최적화가 제한된다.

**예외는 오직 예외 상황에서만 쓰여야 하며, 절대로 일상적인 제어 흐름용으로 쓰여선 안된다**

특정 상태에서만 호출할 수 있는 ‘상태 의존적’ 메서드를 제공하는 클래스는

1. `Iterator`의 `hasNext` 같은 ‘상태 검사 메서드’도 같이 제공해야 한다.
2. 또는 올바르지 않은 상태일 때 빈 `Optional` 이나 `null` 같은 특수한 값을 반환하는 방법도 있다.

‘상태 검사 메서드’, ‘Optional’, ‘null’ 중에서 하나를 선택하는 지침은 다음과 같다.

1. 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 `Optional` 또는 특정 값을 반환한다. (’검사 메서드’와 ‘메서드 호출’ 사이에서 동기화가 깨질 수 있다)
2. 성능이 중요한 상황에서 ‘상태 검사 메서드’가 ‘상태 의존적 메서드’의 작업 일부를 중복 수행한다면 `Optional` 또는 특정 값을 반환한다.
3. 이 외엔 ‘검사 메서드 방식’이 조금 더 낫다.

## [70] 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

자바는 ‘throwable’ 타입으로 ‘**검사 예외(checked exception)**’, ‘**비검사 예외(unchecked exception)**’ - ‘**런타임 예외**’, ‘**에러**’를 제공하는데 언제 어떤 것을 사용할지에 대한 좋은 지침이 있다.

> 검사 예외는 `java.lang.Exception` 이며, 비검사 예외는 `java.lang.RuntimeException` 의 하위 클래스이다.

### **호출하는 쪽에서 복구하리라 여겨지는 상황이라면 ‘검사 예외’를 사용하라**

검사 예외를 던지면 호출자가 그 예외를 `catch` 로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다. 즉, 복구할 수 있는 상황이라면 ‘검사 예외’를 던지자. 그리고 복구에 필요한 정보를 알려주는 메서드도 제공하라.

(검사예외의 반대인 비검사 예외는 복구가 불가능하거나 득보다는 실이 많다는 뜻이므로, 이런 예외를 잡지 않으면 스레드는 적절한 오류 메시지를 뱉으며 중단된다.)

### 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. ex. 배열의 인덱스 접근 에러

에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다. 그렇다고 `Error` 클래스를 상속해 하위 클래스를 만드는 일은 하지 말아야 한다. **직접 구현하는 비검사 throwable은 모두 `RuntimeException` 의 하위 클래스여야 한다**. `Error` 는 상속하지 말아야 할 뿐만 아니라 `AssertionError` 를 제외하고는 `throw` 문으로 직접 던지지 말아야 한다.

## [71] 필요 없는 검사 예외 사용은 피하라

어떤 메서드가 검사 예외를 던질 수 있다고 선언되었다면, 이를 호출하는 코드에선 `catch` 를 두어 처리하거나 바깥으로 던져야 하는데, 어느쪽이든 사용자에게 부담을 주고, 또 자바8부터 추가된 `stream`의 내부에서는 사용할 수도 없기 때문에 부담이 커졌다.

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 `Optional` 을 반환하는 것이다. 단 이 방식의 단점은, 예외가 발생한 이유를 알려주는 정보를 담을 수 없다는 것이다.

**`Optional` 만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.**

## [72] 표준 예외를 사용하라

**Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자. 상황에 부합한다면 항상 표준 예외를 재사용하자.**

### 주로 재사용되는 표준 예외

| 예외                              | 주요 쓰임                                                                                         |
| --------------------------------- | ------------------------------------------------------------------------------------------------- |
| `IllegalArgumentException`        | 허용하지 않는 값이 인수로 건네졌을 때 (`null`은 따로 `NullPointerException` 으로 처리)            |
| `IllegalStateException`           | 객체가 메서드를 수행하기에 적합하지 않은 상태일 때, 또는 인수 값이 무엇이든 어차피 실패했을 경우. |
| `NullPointerException`            | `null` 을 허용하지 않는 메서드에 `null` 을 건넸을 때                                              |
| `IndexOutOfBoundsException`       | 인덱스가 범위를 넘어섰을 때                                                                       |
| `ConcurrentModificationException` | 허용하지 않는 동시 수정이 발견됐을 때                                                             |
| `UnsupportedOperationException`   | 호출한 메서드를 지원하지 않을 때                                                                  |

## [73] 추상화 수준에 맞는 예외를 던지라 → 예외 번역

메서드가 저수준의 예외를 처리하지 않고 바깥으로 전파해버린다면 내부 구현 방식을 드러내어 윗 레벨의 API를 오염시킨다.

**상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다 - ‘예외 번역’.**

**또** 예외를 번역할 때, 저수준에서 발생한 예외가 디버깅에 도움이 된다면 **저수준 예외를 고수준 예외에 함께**(생성자로 주입한다) **실어보내는 게 좋다 - ‘예외 연쇄’**.

```java
// 예외 번역
try {
    ... // 저수준 메서드
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);
}

// 예외 연쇄
try {
    ... // 저수준 메서드
} catch (LowerLevelException cause) {
    // 저수준 예외를 고수준 예외에 실어보낸다.
    throw new HigherLevelException(cause);
}
```

무턱대고 예외를 전파하는 것 보다 예외 번역이 낫지만, 그렇다고 남용해서는 안된다. 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.

또는, 아래 계층에서의 예외를 피할 수 없다면 상위 계층에서 그 예외를 **조용히 처리**하여 호출자에게까지 전파하지 않는 방법이 있다. 단 이 경우엔 프로그래머가 로그를 분석해 추가 조치를 취할 수 있도록 적절한 로깅 기능을 활용하여 기록해두라.

## [74] 메서드가 던지는 모든 예외를 문서화하라

**검사 예외는 항상 따로 따로 선언하고, 각 예외가 발생하는 상황을 javadoc의 `@throws` 태그를 사용하여 정확히 문서화하자.**

**메서드가 던질 수 있는 예외를 각각 `@throws` 태그로 문서화하되, 비검사 예외는 메서드 선언의 `throws` 목록에 넣지 말라**

## [75] 예외의 상세 메시지에 실패 관련 정보를 담으라

예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 예외의 stack trace 정보를 자동으로 출력한다.

Stack trace는 예외 객체의 `toString()` 메서드를 호출해 얻는 문자열이다. 이 정보가 실패의 원인을 분석할 수 있는 유일한 정보인 경우가 많으므로, **사후 분석을 위해 실패 순간의 모든 정보(매개변수와 필드 값)들을 예외 상세 메시지에 담아야 한다**.

## [76] 가능한 한 실패 원자적으로 만들라

**호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다**

### 메서드를 실패 원자적으로 만드는 방법

1. 불변 객체로 설계한다.
2. 작업 수행 전에 유효성 검사를 한다.
3. 객체의 임시 복사본을 만들고 해당 복사본에서 작업을 수행한 후, 작업이 완료되면 본래 것과 교체한다.
4. 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌린다.

하지만 항상 실패 원자성을 달성할 수 있는 것은 아니다. 여러 스레드가 동기화 없이 객체를 수정할 때 `ConcurrentModificationException` 을 잡아 냈다고 해서 해당 객체가 여전히 쓸 수 있는 상태라고 가정해선 안된다.

## [77] 예외를 무시하지 말라

예외는 문제 상황에 잘 대처하기 위해 존재하는데 **`catch` 블록을 비워두면 예외가 존재할 이유가 없어진다.** 못본 척 지나치게 된다면 프로그램은 오류를 내재한 채 동작하다가 어느 순간 갑자기 죽어버릴 수 있다. 무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.

```java
try {
    ...
} catch (SomeException e) {
    // 아무런 처리 없이 예외를 무시하고 있다.
}
```

만약 예외를 무시하기로 했다면 `catch` 블록 안에 그렇게 결정한 이유를 주석으로 남기고, 예외 변수의 이름도 `ignore` 로 바꾸어 알아보기 쉽도록 하자.
