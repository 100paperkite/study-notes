# 4장 - 클래스와 인터페이스

## [15] 클래스와 멤버의 접근 권한을 최소화하라

자바의 접근 제한자(private, protected, public)을 제대로 활용해야 한다.

**모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**

멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 네 가지다.

- private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
- package-private - 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. (기본 값)
- protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서 접근할 수 있다
- public: 모든 곳에서 접근할 수 있다

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않기 때문이다.

클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다. → 클라이언트에서 해당 배열의 값을 수정할 수 있다. **참조하는 객체가** **무조건 불변 객체임을 확인하라**

**모듈 시스템**

Java9에서 두 가지 암묵적 접근 수준이 추가되었다. 모듈은 자신에 속하는 패키지 중 공개(export)할 것들을 (관례상 module-info.java) 선언한다. 해당 패키지를 공개하지 않았다면 어떤 접근자를 쓰던 외부에서 접근이 불가능하다.

## [16] public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다. 하지만 package-private 클래스 혹은 private 중첩 클래스라면 종종 노출하는 편이 나을 때도 있다.

## [17] 변경 가능성을 최소화하라

불변 클래스란 해당 인스턴스 내부의 값을 수정할 수 없는 클래스다. 이 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. 자바에는 `String`, 박싱된 기본 타입 클래스, `BigInteger`, `BigDecimal` 이 여기에 속한다.

클래스를 불변으로 만드려면 다음과 같은 규칙을 따르면 된다

- 상태 변경 메서드를 제공하지 않는다
- 클래스를 확장할 수 없도록 만든다. → final로 선언 or 모든 생성자를 private 혹은 package-private으로 두고 public 정적 팩터리를 제공하는 방법.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 ‘함수형 프로그래밍’이라 한다. 이와는 달리 절차적 혹은 명령형 프로그래밍에서는 메서드에서 피연산자인 자신을 수정해 자신의 상태가 변하게 된다.

**불변 객체는 근본적으로 스레드 안전하기 때문에 따로 동기화 할 필요가 없다**

**불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다**

**불변 객체는 그 자체로 실패 원자성을 제공한다** 실패 원자성이란 ‘메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질’

**불변 객체의 단점은 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다**

- 대안 1) 흔히 쓰일 연산을 예측하여 기본 기능으로 제공한다
- 대안 2) 가변 동반 클래스를 제공한다. (String의 StringBuilder가 그 예시)

**확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다**

## [18] 상속보다는 컴포지션을 사용하라

상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다. 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.

**메서드 호출과 달리 상속은 캡슐화를 깨뜨린다**

- 상위 클래스가 어떻게 구현되느냐에 다라 하위 클래스의 동작에 이상이 생길 수 있다.
- 상위 클래스의 내부 구현이 달라지면 그 여파로 하위 클래스가 오동작 할 수 있다는 말이다.
- 메서드를 재정의 하는 대신 새로운 메서드를 추가하면 괜찮으리라 생각할 수 있지만, 운이 안좋게도 하필 하위 클래스에 추가한 메서드와 시그니처가 같다면 문제가 발생한다

**기존 클래스를 확장하는 대신, 새로운 클래스(이를 Wrapper 클래스라 한다 - Decorator 패턴) 를 만들고 private필드로 기존 클래스의 인스턴스를 참조하게 하자**

→ 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 **컴포지션**이라 한다.

새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 결과를 반환한다 : forwarding

**상속은 반드시 하위 클래스가 상위 클래스의 “진짜” 하위 타입인 상황에서만 쓰여야 한다**. 즉, 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다. B가 진짜 A인가? 로 자문해보자.

## [19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

**상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하지는지(자기사용) 문서로 남겨야 한다**

클래스 자신이 호출하는 또 다른 메서드가 재정의 가능 메서드라면 어떤 순서로 호출되는지, 어떤 영향을 끼치는지 적시해야 한다. → javadoc의 @implSpec 태그

## [20] 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 두 가지이다.

Java8부터 인터페이스도 디폴트 메서드를 제공할 수 있게 되면서 두 매커니즘 다 메서드를 구현된 형태로 제공할 수 있다.

하지만 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. → 자바는 단일 상속만을 지원하기 때문에 큰 제약이다.

반면 인터페이스가 선언한 메서드를 모두 정의하고 그 규약을 잘 지킨 클래스라면 어떤 클래스를 상속했든 같은 타입으로 취급된다.

**인터페이스는 기존 클래스에도 손쉽게 새로 구현해넣을 수 있다. 추상 클래스는 계층 구조상 두 클래스의 공통 조상이어야 하기 때문에 계층구조에 커다란 혼란을 주게된다**

**인터페이스는 믹스인(mixin) 정의에 안성맞춤이다** 믹스인이란 대상 타입의 주된 기능에 선택적 기능을 ‘혼합’한다고 해서 믹스인이라 부른다. 추상 클래스는 기존 클래스에 덧씌울 수 없기 때문에 불가능하다.

**인터페이스는 계층구조가 없는 타입 프레임워크를 만들 수 있다**

인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 정적 멤버도 가질 수 없다(단 private 정적 메서드는 예외). 또한 직접 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.

**인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다**

인터페이스로는 타입을 정의하고, 골격 구현 클래스는 나머지 메서드들까지 구현하면 단순히 골격 구현을 확장하는 것 만으로도 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. **→ Template 메서드 패턴**

```java
static List<Integer> intArrayAsList(int[] a){
  Objects.requireNonNull(a);

  return new AbstractList<>() {
      @Override public int size() {
          return a.length;
      }

      @Override public Integer get(int i) {
          return a[i];
      }

      @Override public Integer set(int i, Integer val){
          int oldVal = a[i];
          a[i] = val;
          return oldVal;
      }
  };
}
```

## [21] 인터페이스는 구현하는 쪽을 생각해 설계하라

디폴트 메서드가 등장하면서 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드를 추가할 수 있게 되었다. 하지만 기존에는 “현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다”는 것을 가정했기 때문에 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다.

**디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.**

기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.

**디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설꼐할 때는 여전히 세심한 주의를 기울여야 한다**

## [22] 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 **타입** 역할을 한다. 달리 말해 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해 주는 것이다. **인터페이스는 오직 이 용도로만 사용해야 한다**

이 지침에 맞지 않는 예로는 소위 상수 인터페이스(메서드 없이 static final 필드로만 가득 찬 인터페이스)라는 것이 있다.

```java
// !!! 안티패턴
public interface PhysicalConstants {
	static final double AVOGADROS_NUMBER = ...;
	static final double ELECTRON_MAS = ...;
}
```

상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다. 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부구현에 해당한다. 클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없다.

상수를 공개할 목적이라면 **인스턴스화 할 수 없는 유틸리티 클래스**에 담아 공개하자.

## [23] 태그 달린 클래스보다는 클래스 계층구조를 활용하라

태그 달린 클래스 : 클래스 내부의 태그(주로 Enum)에 따라 클래스 역할이 바뀌는 클래스

**태그 달린 클래스를 써야 하는 상황은 거의 없다. 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 계층 구조로 대체하는 방법을 생각해보자**

## [24] 멤버 클래스는 되도록 static으로 만들라

중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다. 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며 그 외의 쓰임새가 있다면 top-level 클래스로 만들어야 한다.

중첩 클래스의 종류는 1) 정적 멤버 클래스, 2) (비정적) 멤버 클래스, 3) 익명 클래스, 4) 지역 클래스, 총 네가지이다. 이 중 첫번째를 제외한 나머지는 내부 클래스에 해당한다.

### 정적 멤버 클래스

정적 멤버 클래스는 다른 클래스 안에 선언되고 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와 똑같다.

정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.

### 비정적 멤버 클래스

비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다. 그래서 비정적 멤버 클래스의 인스턴스 메서드에서 `클래스명.this` (정규화된 this) 를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.

따라서 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다. 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문이다.

비정적 멤버클래스는 어떤 클래스의 인스턴스를 감싸 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용하는 **“Adapter 패턴”**을 정의할 때 자주 쓰인다. \*\*\*\*

```java
public class MySet<E> extends AbstractSet<E> {
		// 생략
		@Override public Iterator<E> iterator() {
				return new MyIterator();

		private class MyIterator implements Iterator<E> {
				...
		}
}
```

**멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 `static` 을 붙여서 정적 멤버 클래스로 만들자**

static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 되어 시간과 공간이 소비된다.

**중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고, 그렇지 않다면 지역 클래스로 만들자**

## [25] 톱레벨 클래스는 한 파일에 하나만 담으라

**소스 파일 하나에 톱레벨 클래스를 하나만 담자.**

이 규칙만 따른다면 컴파일러가 한 클래스에 대한 정의를 여러 개 만들어내는 일은 사라진다. 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.
