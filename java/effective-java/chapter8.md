# 8장 - 메서드

## [49] 매개변수가 유효한지 검사하라

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던지며 실패할 수 있다. **메서드나 생성자를 작성할 때 매개변수들에 어떤 제약이 있을 지 생각해야 하며, 제약들을 문서화하고 코드 시작 부분에서 명시적으로 검사해야 한다**

1. public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야한다(`@throws` 자바독 태그를 사용하면 된다)
2. `null` 검사 - 수동으로 하지 말고 자바7에 추가된 `java.util.Objects.requireNonNull` 메서드로 검사하라

## [50] 적시에 방어적 복사본을 만들라

자바라고 해도 다른 클래스로부터의 침범을 노력없이 다 막을 수 있는 것은 아니다. 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.

**생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다** (인스턴스 안에서는 원본이 아닌 복사본을 사용하게 된다.)

**단, 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone` 을 사용해서는 안된다** (`clone`이 악의적인 하위 클래스의 인스턴스를 반환할 수도 있다)

## [51] 메서드 시그니처를 신중히 설계하라

1. **메서드 이름을 신중히 짓자** - 명명 규칙을 따라야 한다
2. **편의 메서드를 너무 많이 만들지 말자** - 확신이 서지 않으면 만들지 말아야 한다. ([YAGNI](https://ko.wikipedia.org/wiki/YAGNI) 참고)
3. **매개변수 목록은 짧게 유지하자** (같은 타입의 매개변수 여러 개가 연달아 나오는 경우 특히 해롭다)
   - 이런 경우 여러 메서드로 쪼갠다.
   - 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
   - **_아이템 [2]_** 의 빌더 패턴을 이용한다.
4. **매개변수의 타입으로는 클래스보다는 인터페이스가 낫다**
5. **`boolean` 보다는 원소 2개짜리 열거 타입이 낫다** (메서드 이름 상 boolean이 의미가 더 명확한 경우는 제외)

## [52] 오버로딩은 신중히 사용하라

**오버로딩은 어느 메서드를 호출할지가 컴파일타임에 정해진다.** 런타임에 타입이 달라지더라도 호출할 메서드를 선택하는 데는 영향을 주지 못한다.

**오버라이딩한 메서드는 런타임에 선택되고, 오버로딩된 메서드는 컴파일타임에 선택된다.**

오버로딩이 혼동을 일으키는 상황을 피해야 하며, 안전하고 보수적으로 가려면

- **매개변수 수가 같은 오버로딩 메서드는 만들지 말자.**
- **서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다** → 서로 근본적으로 다르지 않기 때문이다.
- **오버로딩 대신 메서드 이름을 다르게 지어주는 방법도 고려하자.**

오버로딩 메서드의 매개변수 수가 같더라도 매개변수 중 하나 이상이 “근본적으로 다르다면 **(서로 형변환 할 수 없다면)**” 헷갈릴 일이 없다.

## [53] 가변인수는 신중히 사용하라

인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.

- 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고
- 가변인수는 매번 배열을 새로 할당하므로 사용할 때 성능 문제를 고려해야 한다.
  - 자주 사용되는 가변인수 개수들을 파악해서 오버로딩 메서드를 여러 개 정의해두는 것도 방법이다.

## [54] `null` 이 아닌, 빈 컬렉션이나 배열을 반환하라

컬렉션이나 배열같은 컨테이너가 비었을 때 `null` 을 반환하는 메서드를 사용할 때, 매번 null을 체크하는 방어 코드를 넣어줘야 한다. 그러므로 **빈 컬렉션이나 길이가 0인 배열을 반환하자**.

매번 컬렉션을 할당하는 것이 문제가 될 것 같으면 **빈 ‘불변’ 컬렉션이나 길이 0인 배열을 정의해두고 해당 배열을 반환하자** - `Collections.emptyList`, `Collections.emptySet` … 등등

## [55] `Optional` 반환은 신중히 하라

이전에는 특정 조건에서 값을 반환할 수 없을 때 두 가지 방법을 취했지만 두 방법 모두 허점이 있다.

- 예외를 던진다 → 예외는 진짜 예외적인 상황에서 사용해야하며, 예외가 발생 비용도 만만치 않다(스택 캡쳐)
- `null` 을 반환한다 → 별도의 `null` 처리 코드를 클라이언트가 추가해야 한다.

자바 8부터 `Optional` 이란 선택지가 생겼다. `Optional<T>` 는 `null` 이 아닌 T 타입 참조를 하나 담거나, 혹은 아무것도 담지 않을 수 있다. **결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 `Optional<T>` 를 반환하자**. (단 Optional을 반환하는 메서드에서는 절대 `null` 을 반환하지 말자.)

옵셔널을 사용하면 1) 기본값을 정해두거나 2) 원하는 예외를 던질 수 있다.

**단 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안된다. 오히려 빈 컬렉션을 반환하는 것이 좋다.**

그리고 **성능 문제가 있으므로 박싱된 기본타입을 담은 옵셔널 대신 `OptionalInt`, `OptionalLong` 같은 전용 옵셔널 클래스를 사용하자**

## [56] 공개된 API요소에는 항상 문서화 주석을 작성하라

**Javadoc** 유틸리티로 **문서화 주석을 작성하라. 올바르게 문서화하려면 공개된 모든 클래스, 인터페이스 ,메서드, 필드 선언에 문서화 주석을 달아야 한다.**

- 해당 메서드가 무엇을 하는지 `how` 가 아닌 `what` 을 기술해야 한다.
- 클라이언트가 해당 메서드를 호출하기 위한 전제조건을 모두 나열해야 한다.
- 메서드가 성공적으로 수행된 후에 만족해야하는 사후조건도 모두 나열해야 한다.
- 부작용도 문서화해야 한다.
- 모든 매개변수에 `@param` 태그를, 반환 타입이 `void` 가 아니라면 `@return` 태그를, 모든 예외에 `@throws` 태그를 달아야 한다.
- 스레드 안전 수준도 설명에 포함해야 한다

**잘써진 여러 API문서들을 읽어보면서 문서화 주석을 익히자**
