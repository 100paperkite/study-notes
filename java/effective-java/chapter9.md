# 9장 - 일반적인 프로그래밍 원칙

## [57] 지역변수의 범위를 최소화하라

지역 변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

**가장 처음 쓰일 때 선언하고, 선언과 동시에 초기화하라.** (`try-catch` 문은 예외인데, 이 경우엔 초기화하는 표현식에서 예외를 던질 가능성이 있다면 `try` 블록 안에서 초기화해야 한다.)

반복자를 사용해야 하는 상황이면(remove를 써야 하는 경우 등) `for-each` 문이나 `while` 문 대신 전통적인 `for` 문을 쓰는 것이 낫다. (변수 `i` 의 유효 범위가 `for` 문 안으로 한정되어 복사-붙여넣기의 오류를 없애준다.)

```java
// GOOD
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    // ...
}
```

그리고 **메서드를 작게 유지하고 한 가지 기능에 집중하라.**

## [58] 전통적인 `for` 문 보다는 `for-each` 문을 사용하라

반복자와 인덱스를 사용하지 않으므로 코드가 간결해지며 오류가 날 일도 없다.

`for-each` 문은 컬렉션과 배열은 물론 `Iterable` 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

```java
// 컬렉션과 배열을 순회하는 올바른 관용구
for (Element e : elements) {
    // ...
}
```

### `for-each` 문을 사용할 수 없는 경우 세 가지

1. **파괴적인 필터링** : 순회하면서 원소를 제거해야 한다면 반복자의 `remove` 메서드를 호출해야 한다. (단 자바8부터는 `Collection`의 `removeIf` 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다)
2. **변형** : 순회하면서 값 일부 혹은 전체를 교체해야 한다면 반복자나 인덱스를 사용해야 한다.
3. **병렬 반복** : 여러 컬렉션을 병렬로 순회해야 한다면 반복자와 인덱스 변수를 사용해 명시저으로 제어해야 한다.

## [59] 라이브러리를 익히고 사용하라

바퀴를 재발명하지 말고 **표준 라이브러리를 사용하라. 적어도 `java.lang`, `java.util`, `java.io` 와 그 하위 패키지들에는 익숙해져야 한다.**

## [60] 정확한 답이 필요하다면 `float` 과 `double` 은 피하라

`float` 과 `double` 은 ‘근사치’([IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754) 참고) 이므로 정확한 결과가 필요할 때는 사용하면 안된다.

정확한 결과를 얻으려면 `**BigDecimal`, `int` 혹은 `long` 을 사용해야 한다.\*\* (숫자를 9자리 십진수로 표현할 수 있다면 `int`, 18자리 십진수로 표현할 수 있다면 `long`, 18자리를 넘어가면 BigDecimal를 사용하라)

## [61] 박싱된 기본 타입보다는 기본 타입을 사용하라

**타입 매개변수처럼 꼭 박싱된 기본타입을 써야 하는 경우가 아니라면 기본 타입을 사용하라**

### 박싱 vs 기본 타입의 차이

1. 박싱된 타입은 (참조 객체이므로) identity란 속성을 가지기 때문에 값이 같아도 다르게 식별될 수 있다.

   ```java
   // 잘못 구현된 비교자
   Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j) ? 0 : 1;

   // 두번째 비교인 `==` 비교에서 identity를 검사하므로 오류가 생긴다.
   naturalOrder.compare(new Integer(42), new Integer(42)); // 결과는 0이 아닌 1이다.

   // 문제를 해결하려면 기본타입을 받는 정적 `compare`메서드를 사용하거나
   // 아래처럼 모든 비교를 기본 타입 변수로 수행해야 한다.
   Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
        int i = iBoxed, j = jBoxed; // auto-boxing
        return i < j ? -1 : (i == j ? 0 : 1);
   };
   ```

2. 박싱된 타입은 `null` 을 가질 수 있다.

   **기본타입과 박싱된 타입을 혼용한 연산에서는 기본 타입의 박싱이 자동으로 풀린다** 그리고 `null` 참조를 언박싱하면 예외가 터진다.

   ```java
   public class NullPointerExceptionExample {
        static Integer i;

        public static void main(String[] args) {
            if (i == 42) { // <-- 여기서 NullPointerException이 발생한다.
                System.out.println("출력되지 않음");
            }
        }
    }
   ```

3. 박싱된 타입은 시간과 메모리면에서 비효율적이다.

   ```java
   Long sum = 0L;
   for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i; // 박싱과 언박싱이 일어나므로 느려진다.
   }
   ```

## [62] 다른 타입이 적절하다면 문자열 사용을 피하라

- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
- 문자열은 열거 타입을 대신하기에 적합하지 않다 - **[item 34] 참고**
- 문자열은 혼합 타입을 대신하기에 적합하지 않다. 차라리 전용 클래스를 새로 만들라
- 문자열은 권한(주로 키 값)을 표현하기에 적합하지 않다.

## [63] 문자열은 느리니 주의하라

문자열은 **불변**이기 때문에 두 문자열을 `+` 같은 연산자로 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능이 떨어진다. **성능을 포기하고 싶지 않다면 `String` 대신 `StringBuilder` 를 사용하자**

## [64] 객체는 인터페이스를 사용해 참조하라 - _[51]의 확장_

**적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 모두 인터페이스 타입으로 선언하라.**

나중에 구현 클래스를 교체하고자 한다면 새 클래스의 생성자로만 바꿔주면 되므로 프로그램이 훨씬 유연해진다.

```java
Set<Son> sonset = new LinkedHashSet<>(); // GOOD
LinkedHashSet<Son> sonSet = new LinkedHashSet<>(); // BAD
```

**단, 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다**

1. `String` 과 `BigInteger` 같은 값 클래스.
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체 - ex. `java.io` 의 여러 클래스
   - 이런 경우라도 보통 추상 클래스인 기반 클래스를 사용해 참조하는 것이 좋다.
3. 인터페이스에 없는 특별한 메서드를 제공하는 클래스. - ex. `PriorityQueue`
   - 클래스 타입을 직접 사용하는 경우엔 추가적인 메서드는 꼭 사용해야 할 때만 사용하라.

## [65] 리플렉션보다는 인터페이스를 사용하라

리플렉션 기능(`java.lang.reflect)`을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다. (Class 객체로 해당 클래스의 생성자, 메서드, 필드 인스턴스를 가져올 수 있으며 각각을 조작할 수 있다)

### 단점

- 컴파일 타입 검사가 주는 이점을 하나도 누릴 수 없다.
- 코드가 지저분해지고 장황해진다.
- 성능이 떨어진다.

컴파일 타임에 이용할 수 없는 클래스를 사용해야 한다면 **리플렉션을 인스턴스 생성에만 쓰고 해당 인스턴스는 인터페이스나 상위 클래스로 참조해서 사용하라.**

## [66] 네이티브 메서드는 신중히 사용하라

`JNI(Java Native Inteface)` 는 자바 프로그램이 네이티브 메서드(C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드)를 호출하는 기술이다.

네이티브 메서드의 주요 쓰임은 **1) 플랫폼별 특화 기능을 사용, 2) 네이티브 코드로 작성된 라이브러리 사용, 3) 성능 개선을 목적으로 네이티브 언어로 작성,** 총 세 가지다.

여기서 플랫폼 별 특화 기능은 자바가 성숙해가면서 점차 필요가 줄고 있다(ex. Java 9에 추가된 OS 프로세스에 접근할 수 있는 `process API`). 네이티브 코드로 작성된 라이브러리를 사용해야 한다면 네이티브 메서드를 사용해야 하지만, **성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 권장하지 않는다.**

**네이티브 메서드는, 네이티브 언어가 안전하지 않기에 메모리 취약점에 노출되므로 매우 조심히 사용해야 한다**

## [67] 최적화는 신중히 하라

**섣부른 최적화는 만악의 근원이다.** 성능 때문에 견고한 구조를 희생하지 말라. 빠른 프로그램보다는 좋은 프로그램을 작성하라.

설계단에서 먼저 성능을 반드시 염두에 두고 설계해야 하며(특히 API, 네트워크 프로토콜, 저장용 포맷을 설계하는 경우), 최적화를 해야 한다면 **최적화 시도 전후로 성능을 측정하라.**

## [68] 일반적으로 통용되는 명명 규칙을 따르라

- 패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 지으며, **각 요소들은 모두 소문자 알파벳**(드물게 숫자)으로 이루어진다.
- 조직 바깥에서도 사용될 패키지라면 조직의 **인터넷 도메인 이름을 역순**으로 사용한다. (`com.google` 같은 식)
- 패키지 이름의 각 요소는 **일반적으로 8자 이하의 짧은 단어**로 하며, `utilities` 보단 `util` 같은 **약어**를 추천한다(여러 단어로 구성되어 있다면 약어).
- 클래스와 인터페이스의 이름은 각 단어가 대문자로 시작하는 `PascalCase` 로 작성하며, 널리 통용되는 줄임말을 제외하곤 줄여쓰지 않는다.
- 약자의 경우 첫글자만 대문자로 하는 쪽이 훨씬 많다 (`HttpUrl` 같은 경우처럼 각 약자의 시작과 끝을 명확히 알 수 있기 때문)
- 메서드와 필드 이름은 `camelCase`로 한다.
- 상수 필드는 모두 대문자로 쓰며 밑줄로 구분한다.
- 타입 매개변수의 이름은 보통 한 문자로 표현하며 대부분은 다음과 같은 타입들 중 하나다.
  - `T`, `U`, `V` 또는 `T1`, `T2`, `T3` : 임의의 타입 시퀀스
  - `E` : 컬렉션 원소의 타입
  - `K` : 맵의 키, `V` 맵의 값
  - `X` : 예외
  - `R` : 반환 타입
- 객체를 생성할 수 있는 클래스의 이름은 보통 **단수 명사**나 **명사구**이다.
- 객체를 생성할 수 없는 클래스의 이름은 보통 **복수형 명사**로 짓는다.
- 인터페이스 이름은 클래스와 똑같이 짓거나 `able` 혹은 `ible` 로 끝나는 형용사로 짓는다.
- 반환 타입이 `boolean` 이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 **명사**, **명사구**, **`get` 으로 시작하는 동사구**로 짓는다.
- 객체의 타입을 바꿔서 다른 타입의 또 다른 객체를 반환하는 메서드의 이름은 주로 `toType` 형태로 짓는다.
- 객체의 내용을 다른 뷰로 보여주는 메서드는 `asType` 형태로 짓는다.
- 정적 팩터리의 이름은 다양하지만 `from`, `of`, `valueOf`, `getInstance`, `newInstance`, `instance` 등등을 사용한다.
